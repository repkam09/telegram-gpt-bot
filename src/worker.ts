import { Config } from "./singletons/config";
import { Logger } from "./singletons/logger";
import { DefaultLogger, makeTelemetryFilterString, NativeConnection, Runtime, Worker } from "@temporalio/worker";
import * as agentActivities from "./temporal/agent/activities";
import * as gemstoneActivities from "./temporal/gemstone/activities";
import "./temporal/workflows";

export class HennosTemporalWorker {
    static async init() {
        const server = `${Config.TEMPORAL_HOST}:${Config.TEMPORAL_PORT}`;
        Logger.info(undefined, `Connecting to Temporal server at ${server}...`);
        const connection = await NativeConnection.connect({
            address: server,
        });

        Logger.info(undefined, "Starting Hennos Worker...");
        const agentWorker = await Worker.create({
            connection,
            namespace: Config.TEMPORAL_NAMESPACE,
            taskQueue: Config.TEMPORAL_HENNOS_TASK_QUEUE,
            workflowsPath: require.resolve("./temporal/workflows"),
            activities: agentActivities,
        });

        Logger.info(undefined, "Starting Gemstone Worker...");
        const gemstoneWorker = await Worker.create({
            connection,
            namespace: Config.TEMPORAL_NAMESPACE,
            taskQueue: Config.TEMPORAL_GEMSTONE_TASK_QUEUE,
            workflowsPath: require.resolve("./temporal/workflows"),
            activities: gemstoneActivities,
        });

        return Promise.all([
            agentWorker.run().finally(() => connection.close()),
            gemstoneWorker.run().finally(() => connection.close())
        ]);
    }
}

// Configure Rust Core runtime to collect logs generated by Node.js Workers and Rust Core.
Runtime.install({
    logger: new DefaultLogger("WARN", (entry) => {
        const log = {
            type: "temporal" as const,
            label: entry.meta?.activityId
                ? "activity"
                : entry.meta?.workflowId
                    ? "workflow"
                    : "worker",
            msg: entry.message,
            metadata: entry.meta,
        };

        switch (entry.level) {
            case "DEBUG":
                Logger.logger.debug(log);
                break;
            case "INFO":
                Logger.logger.info(log);
                break;
            case "WARN":
                Logger.logger.warn(log);
                break;
            case "ERROR":
                Logger.logger.error(log);
                break;
            case "TRACE":
                Logger.logger.debug(log);
                break;

            default:
                break;
        }
    }),
    // Telemetry options control how logs are exported out of Rust Core.
    telemetryOptions: {
        logging: {
            filter: makeTelemetryFilterString({ core: "ERROR" }),
        },
    },
});
